[["index.html", "CytoTree Tutorial Chapter 1 Introduction", " CytoTree Tutorial Yuting Dai 2020-10-31 Chapter 1 Introduction Multidimensional flow and mass cytometric assays are widely used for cellular subpopulation identification, tissue microenvironment composition determination, clinical immunophenotyping and differential lineage reconstruction. Modern fluorescence-based flow cytometers typically can detect up to 20 features in one routine experiment, whereas mass cytometers increase the capacity to nearly 50 features. With the rapidly increasing dimensionality and throughput of flow and mass cytometry data, an optimized and complete workflow has yet to be developed to perform trajectory inference and pseudotime estimation on flow and mass cytometry data. Here we present CytoTree, an R/Bioconductor package for trajectory inference, pseudotime estimation and visualization of flow and mass cytometry data. The CytoTree package offers a complete up-to-date analysis workflow for flow and mass cytometry data that includes subpopulation classification, dimensionality reduction, trajectory construction, differentially expressed marker calculation, pseudotime estimation, intermediate state identification and visualization. The CytoTree runs on several platforms, such as UNIX, Windows and macOS, and provides an up-to-date, feature-rich and readily scalable workflow. In this tutorial, we will present: How to install CytoTree. A quick start tutorial of CytoTree. Detailed functionality description of CytoTree. A heterogeneity-based use case using CytoTree. A time-course use case using CytoTree. Structure of CYT object. "],["quick-start.html", "Chapter 2 Quick Start 2.1 Overview of Workflow 2.2 Installation 2.3 Quick-start code 2.4 Visualization", " Chapter 2 Quick Start In this chapter, we will describe the four main functionalities of CytoTree and present the quick-start code template of CytoTree workflow. The data in this chapter are included in the CytoTree package. And through this chapter, you will learn: The workflow of CytoTree. How to build a CYT object. A quick-start code template of CytoTree workflow. A brief code template for visualization of CYT object. And for the detailed version and advanced application of CytoTree, please read Chapter 3 and Chapter 4. 2.1 Overview of Workflow The CytoTree package is developed to complete the majority of standard analysis and visualization workflow for FCS data. In CytoTree workflow, an S4 object in R is built to implement the statistical and computational approach, and all computational functionalities are integrated into one single channel which only requires a specified input data format. Computational functionalities of CytoTree can be divided into four main parts (Fig. 2.1): preprocessing, trajectory, analysis and visualization. Preprocessing. Data import, compensation, quality control, filtration, normalization and merge cells from different samples can be implemented in the preprocessing part. After preprocessing, a matrix that contains clean cytometric signaling data is required to build a CYT object. There are other optional data recommended to build the CYT object, including a data frame containing meta-information of the experiment and a vector contains all markers enrolled in the computational process. Trajectory. Cells built in the CYT object are classified into different clusters based on the expression level of input markers. You can choose different clustering methods by inputting different parameters. After clustering, cells are downsampled in a cluster-dependent fashion to reduce the total cell size and avoid small cluster deletion. Dimensionality reduction for both cells and clusters are also implemented in the clustering procedure. After dimensionality reduction, we use Minimus Spanning Tree (MST) to construct cell trajectory. Analysis. This part is designed for time course FCS data. Before running pseudotime, root cells must be defined first based on users’ prior knowledge. Root cells in CytoTree workflow are the initial cells of the trajectory tree. So it can be set using one vertex node of the tree or a cluster of cells with specific antibodies combination. Intermediate state evaluation is also involved in the pseudotime part. Leaf cells are defined by the end node of the trajectory or the end stage of the experiment. Intermediate state cells are cells with higher betweenness in the graph built on cell-cell connection, which plays an important role between the connection of root cells and leaf cells. Visualization. The visualization part can provide clear and concise visualization of FCS data in an effective and easy-to-comprehend manner. CytoTree package offers various plotting functions to generate customizable and publication-quality plots. A two-dimensional or three-dimensional plot can fit most requirements from dimensionality reduction results. And tree-based plot can visualize cell trajectory as a force-directed layout tree. Other special plots such as heatmap and violin plot are also provided in CytoTree. Figure 2.1 Workflow of CytoTree 2.2 Installation 2.2.1 GitHub This requires the devtools package to be pre-installed first. # If not already installed install.packages(&quot;devtools&quot;) devtools::install_github(&quot;JhuangLab/CytoTree&quot;) library(CytoTree) The link of CytoTree on GitHub can be visited at https://github.com/JhuangLab/CytoTree. 2.2.2 Bioconductor This requires the BiocManager package to be pre-installed first. To install this package, start R (version “4.0”) and enter: if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;CytoTree&quot;) The link of CytoTree on Bioconductor can be visited at https://bioconductor.org/packages/CytoTree/. 2.3 Quick-start code To run CytoTree, the first step is to build a CYT object. Here are the main functions in CytoTree. This figure describes the available functionalities: preprocessing, trajectory, analysis, visualization, and set operations. A short description (black font) and the corresponding function (blue font) are provided for each function. The CytoTree workflow begins with the reading of the FCS data. Compensation, filtration, concatenation, and normalization are included in the preprocessing part. A clean matrix after preprocessing is required to build a CYT object, and the analysis workflows of all other functionalities are all based on the CYT object. The trajectory module contains functions used to perform clustering and dimensionality reduction for cells. The analysis module is based on calculation results from the trajectory part. The visualization part includes functions to generate publication-quality plots from the CYT object. The set operations part includes a function for subsetting a CYT object based on user-defined cells or fetching meta information for clusters and cells during the analysis. # Loading packages suppressMessages({ library(CytoTree) }) # Read fcs files fcs.path &lt;- system.file(&quot;extdata&quot;, package = &quot;CytoTree&quot;) fcs.files &lt;- list.files(fcs.path, pattern = &#39;.FCS$&#39;, full = TRUE) fcs.data &lt;- runExprsMerge(fcs.files, comp = FALSE, transformMethod = &quot;none&quot;) # Build the CYT object cyt &lt;- createCYT(raw.data = fcs.data, normalization.method = &quot;log&quot;) # See information cyt ## CYT Information: ## Input cell number: 600 cells ## Enroll marker number: 18 markers ## Cells after downsampling: 600 cells ################################################ ##### Running CytoTree in one line code ################################################ # Run without dimensionality reduction steps # Run CytoTree as pipeline and visualize as tree cyt &lt;- cyt %&gt;% runCluster() %&gt;% processingCluster() %&gt;% buildTree() ## Mapping data to SOM plotTree(cyt) # Or you can run with dimensionality reduction steps # Run CytoTree as pipeline and visualize as tree cyt &lt;- cyt %&gt;% runCluster() %&gt;% processingCluster() %&gt;% runFastPCA() %&gt;% runTSNE() %&gt;% runDiffusionMap() %&gt;% runUMAP() %&gt;% buildTree() ## Mapping data to SOM plot2D(cyt, item.use = c(&quot;UMAP_1&quot;, &quot;UMAP_2&quot;)) Here we provied the running template of trajectory inference using CYT object is as follows: # Cluster cells by SOM algorithm set.seed(1) cyt &lt;- runCluster(cyt) ## Mapping data to SOM # Processing Clusters cyt &lt;- processingCluster(cyt) # This is an optional step # run Principal Component Analysis (PCA) cyt &lt;- runFastPCA(cyt) # This is an optional step # run t-Distributed Stochastic Neighbor Embedding (tSNE) cyt &lt;- runTSNE(cyt) # This is an optional step # run Diffusion map cyt &lt;- runDiffusionMap(cyt) # This is an optional step # run Uniform Manifold Approximation and Projection (UMAP) cyt &lt;- runUMAP(cyt) # build minimum spanning tree cyt &lt;- buildTree(cyt) # DEGs of different branch diff.list &lt;- runDiff(cyt) # define root cells cyt &lt;- defRootCells(cyt, root.cells = c(32,26)) # run pseudotime cyt &lt;- runPseudotime(cyt) # define leaf cells cyt &lt;- defLeafCells(cyt, leaf.cells = c(30)) # run walk between root cells and leaf cells cyt &lt;- runWalk(cyt) # Save object if (FALSE) { saveRDS(cyt, file = &quot;Path to you output directory&quot;) } 2.4 Visualization The running template of visualization is as follows: # Plot 2D tSNE. And cells are colored by cluster id plot2D(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), color.by = &quot;cluster.id&quot;, alpha = 1, main = &quot;tSNE&quot;, category = &quot;categorical&quot;, show.cluser.id = TRUE) # Plot 2D UMAP. And cells are colored by cluster id plot2D(cyt, item.use = c(&quot;UMAP_1&quot;, &quot;UMAP_2&quot;), color.by = &quot;cluster.id&quot;, alpha = 1, main = &quot;UMAP&quot;, category = &quot;categorical&quot;, show.cluser.id = TRUE) # Plot 2D tSNE. And cells are colored by cluster id plot2D(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), color.by = &quot;branch.id&quot;, alpha = 1, main = &quot;tSNE&quot;, category = &quot;categorical&quot;, show.cluser.id = TRUE) # Plot 2D UMAP. And cells are colored by cluster id plot2D(cyt, item.use = c(&quot;UMAP_1&quot;, &quot;UMAP_2&quot;), color.by = &quot;branch.id&quot;, alpha = 1, main = &quot;UMAP&quot;, category = &quot;categorical&quot;, show.cluser.id = TRUE) # Plot 2D tSNE. And cells are colored by stage plot2D(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), color.by = &quot;stage&quot;, alpha = 1, main = &quot;UMAP&quot;, category = &quot;categorical&quot;) # Plot 2D UMAP. And cells are colored by stage plot2D(cyt, item.use = c(&quot;UMAP_1&quot;, &quot;UMAP_2&quot;), color.by = &quot;stage&quot;, alpha = 1, main = &quot;UMAP&quot;, category = &quot;categorical&quot;) # Tree plot plotTree(cyt, color.by = &quot;D0.percent&quot;, show.node.name = TRUE, cex.size = 1) # Tree plot plotTree(cyt, color.by = &quot;FITC-A&lt;CD43&gt;&quot;, show.node.name = TRUE, cex.size = 1) # plot clusters plotCluster(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), category = &quot;numeric&quot;, size = 100, color.by = &quot;BV510-A&lt;CD45RA&gt;&quot;) # plot pie tree plotPieTree(cyt, cex.size = 3, size.by.cell.number = TRUE) # plot pie cluster plotPieCluster(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), cex.size = 40) # plot heatmap of clusters plotClusterHeatmap(cyt) # plot heatmap of branches plotBranchHeatmap(cyt) # Violin plot plotViolin(cyt, color.by = &quot;cluster.id&quot;, marker = &quot;BV510-A&lt;CD45RA&gt;&quot;, text.angle = 90) ## Warning: `fun.y` is deprecated. Use `fun` instead. # Violin plot plotViolin(cyt, color.by = &quot;branch.id&quot;, marker = &quot;BV510-A&lt;CD45RA&gt;&quot;, text.angle = 90) ## Warning: `fun.y` is deprecated. Use `fun` instead. # UMAP plot colored by pseudotime plot2D(cyt, item.use = c(&quot;UMAP_1&quot;, &quot;UMAP_2&quot;), category = &quot;numeric&quot;, size = 1, color.by = &quot;pseudotime&quot;) # tSNE plot colored by pseudotime plot2D(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), category = &quot;numeric&quot;, size = 1, color.by = &quot;pseudotime&quot;) # denisty plot by different stage plotPseudotimeDensity(cyt, adjust = 1) # Tree plot plotTree(cyt, color.by = &quot;pseudotime&quot;, cex.size = 1.5) # Violin plot plotViolin(cyt, color.by = &quot;cluster.id&quot;, order.by = &quot;pseudotime&quot;, marker = &quot;BV650-A&lt;CD49f&gt;&quot;, text.angle = 90) ## Warning: `fun.y` is deprecated. Use `fun` instead. # trajectory value plotPseudotimeTraj(cyt, var.cols = TRUE) ## `geom_smooth()` using formula &#39;y ~ x&#39; # Heatmap plot plotHeatmap(cyt, downsize = 1000, cluster_rows = TRUE, clustering_method = &quot;ward.D&quot;, color = colorRampPalette(c(&quot;#00599F&quot;,&quot;#EEEEEE&quot;,&quot;#FF3222&quot;))(100)) # plot cluster plotCluster(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), color.by = &quot;traj.value.log&quot;, size = 10, show.cluser.id = TRUE, category = &quot;numeric&quot;) "],["ti.html", "Chapter 3 Trajectory Inference (TI) 3.1 Preprocessing 3.2 Clustering 3.3 Dimenssionality Reduction 3.4 Build Trajectory 3.5 Optimazation", " Chapter 3 Trajectory Inference (TI) In this chapter, we will show you the detailed procedures to perform Trajectory Inference (TI) analysis using CytoTree. The data in this chapter can be download from GitHub via git clone https://github.com/JhuangLab/CytoTree-dataset.git. And through this chapter, you will learn: Performing preprocessing using CytoTree. Performing preprocessing using other packages. Clustering in CytoTree. Dimensionality reduction in CytoTree. How to build the tree-shapes trajectory. How to choose your trajectory. 3.1 Preprocessing This is the preprocessing step for flow cytometry data analysis. In CytoTree workflow, data import, compensation, quality control, filtration, normalization and merge cells from different samples can be implemented in the preprocessing module. In this tutorial, we provided two methods to perform compensation and filtration by using CytoTree and flowCore. 3.1.1 Preprocessing using flowCore This is the preprocessing steps using flowCore. # Loading packages suppressMessages({ library(flowCore) library(LSD) library(CytoTree) }) ######################### # Read Flow Cytometry Data # It can be downloaded via # `git clone https://github.com/JhuangLab/CytoTree-dataset.git` # fcs.path musted be modified based on the download directory from GitHub fcs.path &lt;- &quot;FCS/preprocessing/&quot; fcs.file &lt;- paste0(fcs.path, &quot;D10_raw.fcs&quot;) ########################################### # Get the expression matrix from FCS file ########################################### fcs.data.raw &lt;- flowCore::read.FCS(filename = fcs.file) # Need compensation # If `flow.data@description$SPILL` is not empty, # the matrix of flow cytometry need compensation # you can view fcs.data.raw@description$SPILL using head() fcs.data &lt;- flowCore::compensate(fcs.data.raw, spillover = fcs.data.raw@description$SPILL) ########################################### # Gating ########################################### fcs.exp &lt;- fcs.data@exprs # Plot by FSC-A and SSC-A heatscatter(fcs.exp[, &quot;FSC-A&quot;], fcs.exp[, &quot;SSC-A&quot;], cexplot = 0.3, main = &quot;Raw FCS data&quot;, xlab = &quot;FSC-A&quot;, ylab = &quot;SSC-A&quot;, xlim = c(0, 2.5E5), ylim = c(0, 2.5E5)) fcs.exp &lt;- fcs.exp[which((fcs.exp[, &quot;FSC-A&quot;] &gt; 7E4) &amp; (fcs.exp[, &quot;FSC-A&quot;] &lt; 1.8E5)), ] fcs.exp &lt;- fcs.exp[which((fcs.exp[, &quot;SSC-A&quot;] &gt; 3E4) &amp; (fcs.exp[, &quot;SSC-A&quot;] &lt; 1.5E5)), ] heatscatter(fcs.exp[, &quot;FSC-A&quot;], fcs.exp[, &quot;SSC-A&quot;], cexplot = 0.3, main = &quot;Filtered by FSC-A and SSC-A&quot;, xlab = &quot;FSC-A&quot;, ylab = &quot;SSC-A&quot;, xlim = c(0, 2.5E5), ylim = c(0, 2.5E5)) # Plot by FSC-H and FSC-W heatscatter(fcs.exp[, &quot;FSC-H&quot;], fcs.exp[, &quot;FSC-W&quot;], cexplot = 0.3, main = &quot;Filtered by FSC-A and SSC-A&quot;, xlab = &quot;FSC-H&quot;, ylab = &quot;FSC-W&quot;, xlim = c(0, 2.5E5), ylim = c(0, 2.5E5)) fcs.exp &lt;- fcs.exp[which((fcs.exp[, &quot;FSC-H&quot;] &gt; 4E4) &amp; (fcs.exp[, &quot;FSC-H&quot;] &lt; 1.2E5)), ] fcs.exp &lt;- fcs.exp[which((fcs.exp[, &quot;FSC-W&quot;] &gt; 6E4) &amp; (fcs.exp[, &quot;FSC-W&quot;] &lt; 1.2E5)), ] # Plot by FSC-H and FSC-W heatscatter(fcs.exp[, &quot;FSC-H&quot;], fcs.exp[, &quot;FSC-W&quot;], cexplot = 0.3, main = &quot;Filtered by FSC-H and FSC-W&quot;, xlab = &quot;FSC-H&quot;, ylab = &quot;FSC-W&quot;, xlim = c(0, 2.5E5), ylim = c(0, 2.5E5)) # Plot by SSC-H and SSC-w heatscatter(fcs.exp[, &quot;SSC-H&quot;], fcs.exp[, &quot;SSC-W&quot;], cexplot = 0.3, main = &quot;Filtered by FSC-H and FSC-W&quot;, xlab = &quot;SSC-H&quot;, ylab = &quot;SSC-W&quot;, xlim = c(0, 2.5E5), ylim = c(0, 2.5E5)) fcs.exp &lt;- fcs.exp[which((fcs.exp[, &quot;SSC-H&quot;] &gt; 2E4) &amp; (fcs.exp[, &quot;SSC-H&quot;] &lt; 1.2E5)), ] fcs.exp &lt;- fcs.exp[which((fcs.exp[, &quot;SSC-W&quot;] &gt; 6E4) &amp; (fcs.exp[, &quot;SSC-W&quot;] &lt; 1.1E5)), ] # Plot by SSC-H and SSC-w heatscatter(fcs.exp[, &quot;SSC-H&quot;], fcs.exp[, &quot;SSC-W&quot;], cexplot = 0.3, main = &quot;Filtered by SSC-H and SSC-W&quot;, xlab = &quot;SSC-H&quot;, ylab = &quot;SSC-W&quot;, xlim = c(0, 2.5E5), ylim = c(0, 2.5E5)) # Plot by CD43 and CD31 heatscatter(log10(abs(fcs.exp[, &quot;FITC-A&quot;])+1), log10(abs(fcs.exp[, &quot;BV605-A&quot;])+1), cexplot = 0.3, main = &quot;After gating&quot;, xlab = &quot;CD43&quot;, ylab = &quot;CD31&quot;, xlim = c(0, 5), ylim = c(0, 5)) # Plot by CD43 and CD31 heatscatter(log10(abs(fcs.exp[, &quot;APC-A&quot;])+1), log10(abs(fcs.exp[, &quot;BV650-A&quot;])+1), cexplot = 0.3, main = &quot;After gating&quot;, xlab = &quot;CD34&quot;, ylab = &quot;CD49f&quot;, xlim = c(0, 5), ylim = c(0, 5)) # Plot by CD43 and CD31 heatscatter(log10(abs(fcs.exp[, &quot;PE-Cy7-A&quot;])+1), log10(abs(fcs.exp[, &quot;BV421-A&quot;])+1), cexplot = 0.3, main = &quot;After gating&quot;, xlab = &quot;CD38&quot;, ylab = &quot;CD90&quot;, xlim = c(0, 5), ylim = c(0, 5)) # Output FCS file fcs.data@exprs &lt;- fcs.exp flowCore::write.FCS(fcs.data, filename = &quot;FCS/basic/D10.fcs&quot;) ## [1] &quot;FCS/basic/D10.fcs&quot; # Read FCS file and then start your analysis fcs.exp &lt;- CytoTree::runExprsExtract(&quot;FCS/basic/D10.fcs&quot;, transformMethod = &quot;none&quot;, comp = F, showDesc = F) # Show marker description in each panel recol &lt;- c(`FITC-A` = &quot;CD43&quot;, `APC-A` = &quot;CD34&quot;, `BV421-A` = &quot;CD90&quot;, `BV510-A` = &quot;CD45RA&quot;, `BV605-A` = &quot;CD31&quot;, `BV650-A` = &quot;CD49f&quot;, `BV 735-A` = &quot;CD73&quot;, `BV786-A` = &quot;CD45&quot;, `PE-A` = &quot;FLK1&quot;, `PE-Cy7-A` = &quot;CD38&quot;) colnames(fcs.exp)[match(names(recol), colnames(fcs.exp))] = recol fcs.exp &lt;- fcs.exp[, recol] # build CYT object cyt &lt;- createCYT(raw.data = fcs.exp, normalization.method = &quot;log&quot;) cyt ## CYT Information: ## Input cell number: 5667 cells ## Enroll marker number: 10 markers ## Cells after downsampling: 5667 cells 3.1.2 Preprocessing using CytoTree This is the preprocessing steps using CytoTree. In CytoTree, we provide gatingMatrix to gate the matrix and filter unwanted cells. The first step is to read FCS data use runExprsExtract. If the compensation is needed, set comp = TRUE. Then you can use heatscatter to plot the cytometry data and define the gating parameters. # Loading packages suppressMessages({ library(LSD) library(CytoTree) }) ######################### # Read Flow Cytometry Data # It can be downloaded via # `git clone https://github.com/JhuangLab/CytoTree-dataset.git` # fcs.path musted be modified based on the download directory from GitHub fcs.path &lt;- &quot;FCS/preprocessing/&quot; fcs.file &lt;- paste0(fcs.path, &quot;D10_raw.fcs&quot;) ########################################### # Get the expression matrix from FCS file ########################################### # Need compensation # If the flow cytometry need compensation, set `comp = TRUE` cyt.data &lt;- CytoTree::runExprsExtract(fcs.file, comp = TRUE, transformMethod = &quot;none&quot;, showDesc = FALSE) ## Compensation is applied on FCS/preprocessing/D10_raw.fcs # Scatter plot heatscatter(cyt.data[, &quot;FSC-A&quot;], cyt.data[, &quot;SSC-A&quot;], cexplot = 0.3, main = &quot;Raw FCS data&quot;, xlab = &quot;FSC-A&quot;, ylab = &quot;SSC-A&quot;) ########################################### # Gating ########################################### # Gating using the sample parameters cyt.data.gating &lt;- gatingMatrix(cyt.data, lower.gate = c(`FSC-A` = 7E4, `SSC-A` = 3E4, `FSC-H` = 4E4, `FSC-W` = 6E4, `SSC-H` = 2E4, `SSC-W` = 6E4), upper.gate = c(`FSC-A` = 1.8E5, `SSC-A` = 1.5E5, `FSC-H` = 1.2E5, `FSC-W` = 1.2E5, `SSC-H` = 1.2E5, `SSC-W` = 1.1E5)) # Plot by CD43 and CD31 heatscatter(log10(abs(cyt.data.gating[, &quot;FITC-A&quot;])+1), log10(abs(cyt.data.gating[, &quot;BV605-A&quot;])+1), cexplot = 0.3, main = &quot;After gating&quot;, xlab = &quot;CD43&quot;, ylab = &quot;CD31&quot;, xlim = c(0, 5), ylim = c(0, 5)) # Plot by CD43 and CD31 heatscatter(log10(abs(cyt.data.gating[, &quot;APC-A&quot;])+1), log10(abs(cyt.data.gating[, &quot;BV650-A&quot;])+1), cexplot = 0.3, main = &quot;After gating&quot;, xlab = &quot;CD34&quot;, ylab = &quot;CD49f&quot;, xlim = c(0, 5), ylim = c(0, 5)) # Plot by CD43 and CD31 heatscatter(log10(abs(cyt.data.gating[, &quot;PE-Cy7-A&quot;])+1), log10(abs(cyt.data.gating[, &quot;BV421-A&quot;])+1), cexplot = 0.3, main = &quot;After gating&quot;, xlab = &quot;CD38&quot;, ylab = &quot;CD90&quot;, xlim = c(0, 5), ylim = c(0, 5)) # Show marker description in each panel # We highly recommend this step. recol &lt;- c(`FITC-A` = &quot;CD43&quot;, `APC-A` = &quot;CD34&quot;, `BV421-A` = &quot;CD90&quot;, `BV510-A` = &quot;CD45RA&quot;, `BV605-A` = &quot;CD31&quot;, `BV650-A` = &quot;CD49f&quot;, `BV 735-A` = &quot;CD73&quot;, `BV786-A` = &quot;CD45&quot;, `PE-A` = &quot;FLK1&quot;, `PE-Cy7-A` = &quot;CD38&quot;) colnames(cyt.data.gating)[match(names(recol), colnames(cyt.data.gating))] = recol cyt.data.gating &lt;- cyt.data.gating[, recol] # build CYT object and start your analysis cyt &lt;- createCYT(raw.data = cyt.data.gating, normalization.method = &quot;log&quot;) # Show CYT object cyt ## CYT Information: ## Input cell number: 5667 cells ## Enroll marker number: 10 markers ## Cells after downsampling: 5667 cells 3.2 Clustering For clustering in CytoTree, six methods were integrated to classify the cells into different subpopulations: SOM, k-means clustering (kmeans), clara, phenoGraph, hclust and mclust, Each method is relatively independent and can be performed using CytoTree::runCluster by choosing different parameters. The default parameter is som (SOM algorithm). After performing the clustering of all cells, the metadata information in the CYT object will show a new column containing the cluster id of each cell, which can be fetched by the CytoTree::fetchPlotMeta function. After clustering, the cluster-dependent downsampling and dimensionality reduction are applied to each cluster. If the total cell sample size is over 100,000, it is better to perform downsampling to reduce the computational time. After that, the processing of clusters is performed. Four-dimensional reduction methods are applied to each cluster, including PCA, tSNE, diffusion maps, and UMAP. # Loading packages suppressMessages({ library(CytoTree) library(ggplot2) library(ggthemes) }) ######################### # Read Flow Cytometry Data # It can be downloaded via # `git clone https://github.com/JhuangLab/CytoTree-dataset.git` # fcs.path musted be modified based on the download directory from GitHub fcs.path &lt;- &quot;FCS/basic/&quot; fcs.file &lt;- paste0(fcs.path, &quot;FR-FCM-ZY9R-Bone_Marrow_cytof.fcs&quot;) ########################################### # Get the expression matrix from FCS file ########################################### # If you want to see the description of each panel, Set showDesc = T. cyt.data &lt;- CytoTree::runExprsExtract(fcs.file, comp = FALSE, transformMethod = &quot;autoLgcl&quot;, showDesc = FALSE) # build CYT object and start your analysis # If you don&#39;t want to see the running log information, set verbose FALSE # If there is only one case in your analysis workflow, you can just set stage = &quot;D0&quot; cyt &lt;- createCYT(raw.data = cyt.data, normalization.method = &quot;none&quot;) # Show cyt object cyt ## CYT Information: ## Input cell number: 236187 cells ## Enroll marker number: 13 markers ## Cells after downsampling: 236187 cells Clustering using default parameters. The default value of xdim and ydim using SOM clustering is 6. If you want to use other clustering methods, choose different parameters, like som, kmeans, clara, phenograph, hclust, and mclust. The related function names of these clustering methods were runSOM, runKmeans, runPhenograph, runHclust and runMclust. You can use ?runSOM to see the meaning of the parameters in runSOM. # The CytoTree provides multiple methods to cluster cells by # choosing different parameters, som, kmeans, clara, phenoGraph, # and hclust. By default is som. set.seed(1) cyt &lt;- runCluster(cyt) ## Mapping data to SOM # Preprocessing of Clusters # If the cell number is too large, for example, more than 50,000, # cluster-based downsampling is recommended to reduce computation # load and save computation time. # If the downsampling.size is 0.1, it means 10% cell # will be kept in the further analysis. By default is 1. cyt &lt;- processingCluster(cyt, downsampling.size = 0.1) # Visualization for cluster plotCluster(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), category = &quot;categorical&quot;, size = 100, show.cluser.id = TRUE) Clustering using SOM alogrithm. You can use ?runSOM to see more detailed information. The function runSOM(cyt, xdim = 10, ydim = 10) is equal to runCluster(cyt, cluster.method = \"som\", xdim = 10, ydim = 10). # You can set xdim and ydim to specify the number of clusters # the cluster number is xdim * ydim set.seed(1) cyt &lt;- runCluster(cyt, cluster.method = &quot;som&quot;, xdim = 10, ydim = 10) ## Mapping data to SOM # processing clusters cyt &lt;- processingCluster(cyt, downsampling.size = 0.1) # Visualization for clusters plotCluster(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), category = &quot;categorical&quot;, size = 100, show.cluser.id = TRUE) Clustering using Kmeans alogrithm. You can use ?runKmeans to see more detailed information. # Kmeans cluster, you can set k to specify the number of clusters set.seed(1) cyt &lt;- runCluster(cyt, cluster.method = &quot;kmeans&quot;, k = 100) ## Warning: did not converge in 10 iterations # processing clusters cyt &lt;- processingCluster(cyt, downsampling.size = 0.1) # Visualization for cluster plotCluster(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), category = &quot;categorical&quot;, size = 100, show.cluser.id = TRUE) Clustering using Clara alogrithm. You can use ?runClara to see more detailed information. # Clara cluster, you can set k to specify the number of clusters set.seed(1) cyt &lt;- runCluster(cyt, cluster.method = &quot;clara&quot;, k = 100) # processing clusters cyt &lt;- processingCluster(cyt, downsampling.size = 0.1) # Visualization for clusters plotCluster(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), category = &quot;categorical&quot;, size = 100, show.cluser.id = TRUE) Clustering using Hclust and phenoGraph algorithm. You can use ?runHclust or ?runPhenograph to see more detailed information. These two methods will take a relatively long time. So for data with a large cell size, we do not recommend these two methods. # Hclust cluster, you can set k to specify the number of clusters # Hclust runs only the cell number is less than 50,000. # Or it will take lots of time if (dim(cyt.data)[1] &lt; 10000) { set.seed(1) cyt &lt;- runCluster(cyt, cluster.method = &quot;hclust&quot;, k = 100) } # phenoGraph cluster. The number of clusters can not be modified # phenoGraph runs only the cell number is less than 10,000. # Or it will take lots of time if (dim(cyt.data)[1] &lt; 10000) { cyt &lt;- runCluster(cyt, cluster.method = &quot;phenograph&quot;) } 3.3 Dimenssionality Reduction Four methods are provided in the dimensionality reduction module: PCA, tSNE, diffusion maps and UMAP. These methods can be implemented separately by CytoTree::runFastPCA, CytoTree::runTSNE, CytoTree::runDiffusionMaps and CytoTree::runUMAP. The linear and nonlinear dimensionality reduction techniques were developed for the analysis of any type of multidimensional data and enable us to visualize it in two or three dimensions. These methods are relatively independent and can be called by different functions in CytoTree. Also, these functions are optional steps. First, we will change the clustering method to SOM. # By default is som, so we change the clustering method to som set.seed(8) cyt &lt;- runCluster(cyt, cluster.method = &quot;som&quot;, xdim = 10, ydim = 10) ## Mapping data to SOM # Preprocessing of Clusters cyt &lt;- processingCluster(cyt, perplexity = 5, downsampling.size = 0.1, force.resample = TRUE) cyt ## CYT Information: ## Input cell number: 236187 cells ## Enroll marker number: 13 markers ## Cells after downsampling: 23662 cells Perfroming dimensionality reduction. # Four popular dimensionality reduction method are integrated # in CytoTree, namely PCA, tSNE, diffusion maps and UMAP. # This four steps are optional steps # run Principal Component Analysis (PCA) cyt &lt;- runFastPCA(cyt) # run t-Distributed Stochastic Neighbor Embedding (tSNE) set.seed(1) cyt &lt;- runTSNE(cyt) # run Diffusion map cyt &lt;- runDiffusionMap(cyt) # run Uniform Manifold Approximation and Projection (UMAP) cyt &lt;- runUMAP(cyt) After performing the dimensionality reduction, the CytoTree::plot2D or CytoTree::plot3D function can be used to visualize the distribution of the cells. ################################### #### Visualization ################################### # 2D plot plot2D(cyt, item.use = c(&quot;PC_1&quot;, &quot;PC_2&quot;), color.by = &quot;CD3&quot;, alpha = 1, main = &quot;PCA&quot;, category = &quot;numeric&quot;) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;,&quot;#EEEEEE&quot;,&quot;#FF3222&quot;)) # 2D plot plot2D(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), color.by = &quot;CD3&quot;, alpha = 1, main = &quot;tSNE&quot;, category = &quot;numeric&quot;) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;,&quot;#EEEEEE&quot;,&quot;#FF3222&quot;)) # 2D plot plot2D(cyt, item.use = c(&quot;DC_1&quot;, &quot;DC_2&quot;), color.by = &quot;CD3&quot;, alpha = 1, main = &quot;Diffusion Maps&quot;, category = &quot;numeric&quot;) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;,&quot;#EEEEEE&quot;,&quot;#FF3222&quot;)) # 2D plot plot2D(cyt, item.use = c(&quot;UMAP_1&quot;, &quot;UMAP_2&quot;), color.by = &quot;CD3&quot;, alpha = 1, main = &quot;UMAP&quot;, category = &quot;numeric&quot;) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;,&quot;#EEEEEE&quot;,&quot;#FF3222&quot;)) # 2D plot plot2D(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), color.by = &quot;cluster.id&quot;, alpha = 1, main = &quot;tSNE&quot;, category = &quot;categorical&quot;, show.cluser.id = T) # 3D plot plot3D(cyt, item.use = c(&quot;DC_1&quot;, &quot;DC_2&quot;, &quot;DC_3&quot;), color.by = &quot;CD3&quot;, main = &quot;Diffusion Maps CD3&quot;, category = &quot;numeric&quot;, size = 0.2, color.theme = c(&quot;#00599F&quot;,&quot;#EEEEEE&quot;,&quot;#FF3222&quot;)) # 3D plot plot3D(cyt, item.use = c(&quot;PC_1&quot;, &quot;PC_2&quot;, &quot;PC_3&quot;), color.by = &quot;CD3&quot;, main = &quot;PCA CD3&quot;, category = &quot;numeric&quot;, size = 0.2, color.theme = c(&quot;#00599F&quot;,&quot;#EEEEEE&quot;,&quot;#FF3222&quot;)) # 3D plot plot3D(cyt, item.use = c(&quot;PC_1&quot;, &quot;PC_2&quot;, &quot;CD4&quot;), color.by = &quot;CD8&quot;, main = &quot;PCA relation with CD8&quot;, category = &quot;numeric&quot;, size = 0.2, color.theme = c(&quot;#00599F&quot;,&quot;#EEEEEE&quot;,&quot;#FF3222&quot;)) # 3D plot plot3D(cyt, item.use = c(&quot;CD45&quot;, &quot;CD4&quot;, &quot;CD8&quot;), color.by = &quot;CD45&quot;, main = &quot;marker expression by CD45&quot;, category = &quot;numeric&quot;, size = 0.2, color.theme = c(&quot;#00599F&quot;,&quot;#EEEEEE&quot;,&quot;#FF3222&quot;)) 3.4 Build Trajectory Trajectory construction in CytoTree is based on the MST algorithm. An edge-weighted undirected graph is built to connect all nodes identified by the clustering function based on the coordinates of the dimensionality reduction or expression matrix of the cell surface markers. After the trajectory is built, branch analysis will be performed, and all clusters will be divided into different branches according to the Louvain algorithm. Before constructing the trajectory, we need to calculate the coordinates of each cluster first. Users could construct the trajectory based on the expression profile or using the four dimensionality reduction coordinates. When using the expression matrix to construct the trajectory, the coordinates of the cluster was the expression value of each marker in this cluster. The performance of the tree-shaped trajectory calculated by different compensation of the clustering methods and dimensionality reduction methods was different. Build tree using raw expression matrix # CytoTree provides five method to build the tree-shaped trajectory: # 1. Raw expression matrix # 2. PCA # 3. tSNE # 4. Diffusion maps # 5. UMAP # 1. Build tree using raw expression matrix cyt &lt;- buildTree(cyt, dim.type = &quot;raw&quot;) # Tree plot plotTree(cyt, color.by = &quot;CD3&quot;, show.node.name = F, cex.size = 1) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;, &quot;#EEEEEE&quot;, &quot;#FF3222&quot;)) Build tree using PCA # 2. Build tree using PCA cyt &lt;- buildTree(cyt, dim.type = &quot;pca&quot;, dim.use = 1:4) # Tree plot plotTree(cyt, color.by = &quot;CD3&quot;, show.node.name = F, cex.size = 1) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;, &quot;#EEEEEE&quot;, &quot;#FF3222&quot;)) Build tree using tSNE # 3. Build tree using tSNE cyt &lt;- buildTree(cyt, dim.type = &quot;tsne&quot;, dim.use = 1:2) # Tree plot plotTree(cyt, color.by = &quot;CD3&quot;, show.node.name = F, cex.size = 1) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;, &quot;#EEEEEE&quot;, &quot;#FF3222&quot;)) Build tree using Diffusion maps # 4. Build tree using Diffusion maps cyt &lt;- buildTree(cyt, dim.type = &quot;dc&quot;, dim.use = 1:5) # Tree plot plotTree(cyt, color.by = &quot;CD3&quot;, show.node.name = F, cex.size = 1) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;, &quot;#EEEEEE&quot;, &quot;#FF3222&quot;)) Build tree using UMAP # 5. Build tree using UMAP cyt &lt;- buildTree(cyt, dim.type = &quot;umap&quot;, dim.use = 1:2) # Tree plot plotTree(cyt, color.by = &quot;CD3&quot;, show.node.name = FALSE, cex.size = 1) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;, &quot;#EEEEEE&quot;, &quot;#FF3222&quot;)) 3.5 Optimazation The way to choose trajectory was based on two baselines: (i) whether the trajectory fits the real biological progress. (ii) try more combinations of parameters of cluster numbers, cluster methods and dimensionality reduction methods to see whether the tendency of the trajectory kept in common. Generally, after analyzing with biological data, the recommended method for clustering was SOM, and the recommended methods to construction trajectory were the expression profile, tSNE or UMAP. The default workflow in CytoTree package was SOM clustering and construction trajectory using the expression profile. # By combining with biological significance, we choose som clustering # and tsne method to build the trajectory cyt &lt;- buildTree(cyt, dim.type = &quot;tsne&quot;, dim.use = 1:2) cyt@meta.data$branch.id &lt;- paste0(&quot;B&quot;, cyt@meta.data$branch.id) # plot tree plotTree(cyt, color.by = &quot;branch.id&quot;, show.node.name = T, cex.size = 1) ############# Modify branch id branch.id &lt;- cyt@meta.data$branch.id branch.id[branch.id %in% c(&quot;B5&quot;, &quot;B2&quot;, &quot;B10&quot;)] = &quot;CD4 T cells&quot; branch.id[branch.id %in% c(&quot;B7&quot;, &quot;B13&quot;)] = &quot;CD8 T cells&quot; branch.id[branch.id %in% c(&quot;B1&quot;,&quot;B6&quot;,&quot;B12&quot;)] = &quot;Megakaryocytic&quot; branch.id[branch.id %in% c(&quot;B3&quot;)] = &quot;DCs&quot; branch.id[branch.id %in% c(&quot;B11&quot;)] = &quot;B cells&quot; branch.id[branch.id %in% c(&quot;B4&quot;,&quot;B8&quot;,&quot;B9&quot;,&quot;B14&quot;)] = &quot;Myeloid&quot; # In the biological analysis, we may found some clusters are # in the wrong branch, or division of the branch is insufficient. # We recommend modify the branch based on the marker expression branch.id[cyt@meta.data$cluster.id %in% c(74,36,89,11)] = &quot;HSCs&quot; branch.id[cyt@meta.data$cluster.id %in% c(62,14)] = &quot;CD8 T cells&quot; branch.id[cyt@meta.data$cluster.id %in% c(72)] = &quot;B cells&quot; # Refine branch ID cyt@meta.data$branch.id &lt;- branch.id # Plot tree plotTree(cyt, color.by = &quot;branch.id&quot;, show.node.name = TRUE, cex.size = 1) # tSNE plot for branches plot2D(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), color.by = &quot;branch.id&quot;, alpha = 1, main = &quot;tSNE&quot;, category = &quot;categorical&quot;, show.cluser.id = FALSE) # Run differential expressed markers of different branch diff.info &lt;- runDiff(cyt) # plot heatmap of clusters and branches plotClusterHeatmap(cyt) plotClusterHeatmap(cyt, color = colorRampPalette(c(&quot;purple&quot;,&quot;white&quot;,&quot;yellow&quot;))(100)) plotBranchHeatmap(cyt, colorRampPalette(c(&quot;#00599F&quot;, &quot;#FFFFFF&quot;, &quot;#FF3222&quot;))(100), clustering_method = &quot;complete&quot;) "],["analysis.html", "Chapter 4 Analysis of TI 4.1 Pseudotime 4.2 Intermediate States", " Chapter 4 Analysis of TI This chapter will show you the feature extraction and cell state refinement, including pseudotime estimation and intermediate state cell analysis. 4.1 Pseudotime In this part, we will use the CYT object generated in Trajectory Inference chapter 3. The algorithm used to estimate pseudotime was based on prior knowledge derivation. The steps to estimate pseudotime could be divided into four parts. Step 1, the definition of root cells. A root cell was the initiation site of differentiation, or the start point of the biogical process. The pseudotime in root cells was first set up to zero. Step 2, construction of the graph to connect all cells using the k-nearest neighbors (KNN) algorithm. Step 3, calculation of distance from root cells to all other cells by shortest paths. Step 4, calculation of pseudotime of each cell. Cytotree provides a convenient way to calculate pseudotime. # Set HSPCs as root cells cyt &lt;- defRootCells(cyt, root.cells = c(36,89,11)) cyt &lt;- runPseudotime(cyt, dim.type = &quot;raw&quot;) And Cytotree provides a series of visualization functions to illustrate pseudotime. # Rename stage in meta.data cyt@meta.data$stage &lt;- cyt@meta.data$branch.id # Visualization for pseudotime plot2D(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), category = &quot;numeric&quot;, size = 1, color.by = &quot;pseudotime&quot;) + scale_colour_gradientn(colors = c(&quot;#F4D31D&quot;, &quot;#FF3222&quot;,&quot;#7A06A0&quot;)) # Visualization for pseudotime in Tree plotTree(cyt, color.by = &quot;pseudotime&quot;, cex.size = 1) + scale_colour_gradientn(colors = c(&quot;#F4D31D&quot;,&quot;#FF3222&quot;,&quot;#7A06A0&quot;)) # Visualization for pseudotime density plotPseudotimeDensity(cyt, adjust = 2) # Visualization for the correlation of pseudotime and markers plotPseudotimeTraj(cyt, var.cols = TRUE) + scale_colour_gradientn(colors = c(&quot;#F4D31D&quot;, &quot;#FF3222&quot;,&quot;#7A06A0&quot;)) ## `geom_smooth()` using formula &#39;y ~ x&#39; 4.2 Intermediate States After pseudotime estimation, all cells were reordered by pseudotime and the KNN network could be modified based on pseudotime. When the pseudotime of cell i was greater than cell j, the path from cell i to cell j could be accessed. To calculate intermediate state cells, the leaf cells need to be defined first. The leaf cells were the terminal site of differentiation. During the biological process, the differentiation was always multidirectional. The intermediate state cells were the cells that occurred most likely in the shortest path between leaf cells and root cells based on the modified KNN network. ##### View Trajectory Tree plotTree(cyt, color.by = &quot;branch.id&quot;, show.node.name = TRUE, cex.size = 1) ###### Intermediate state cells for CD8 T cells cyt &lt;- defLeafCells(cyt, leaf.cells = c(99,97)) cyt &lt;- runWalk(cyt, verbose = TRUE) ## 2020-10-31 19:36:46 Calculating walk between root.cells and leaf.cells . ## 2020-10-31 19:36:49 Generating an adjacency matrix. ## 2020-10-31 19:37:57 Walk forward. ## 2020-10-31 19:38:03 Calculating walk completed. cyt@meta.data$traj.value.log.CD8T &lt;- cyt@meta.data$traj.value.log ### fetch plot information plot.meta &lt;- fetchPlotMeta(cyt, markers = colnames(cyt.data)) # heatmap for CD8 T cells library(pheatmap) plot.meta.sub &lt;- plot.meta[which(plot.meta$traj.value.log.CD8T &gt; 0), ] plot.meta.sub &lt;- plot.meta.sub[order(plot.meta.sub$pseudotime), ] pheatmap(t(plot.meta.sub[, colnames(cyt.data)]), scale = &quot;row&quot;, cluster_rows = T, cluster_cols = F, cluster_method = &quot;ward.D&quot;, color = colorRampPalette(c(&quot;blue&quot;,&quot;blue&quot;,&quot;blue&quot;,&quot;white&quot;,&quot;red&quot;,&quot;red&quot;,&quot;red&quot;))(100), fontsize_col = 0.01) "],["time-course-data-use-case.html", "Chapter 5 Time-course data use case 5.1 Step 1. Preprocessing 5.2 Step 2. Trajectory 5.3 Step 3. Pseudotime 5.4 Step 4. Subset CYT", " Chapter 5 Time-course data use case To illustrate the usage of CytoTree on differential trajectory reconstruction of time-course FCS data, we used a flow cytometry dataset of ten-day hematopoietic differentiation from the hESC line HUES9 on the basis of some modification of the previous work. By adding different cytokine combinations on different days, HUES9 cells (CD90+CD49f+ on Day 0, D0) were directionally differentiated into mesodermal cells (FLK1+, D4), hemogenic endothelium (CD34+CD31+CD43-, D6) and hematopoietic stem/progenitor cells (HSPCs, CD34+CD43+CD38-CD45RA-CD90+, D8) in succession. Ten cell surface markers (CD90, CD49f, FLK1, CD34, CD31, CD73, CD43, CD45, CD45RA, and CD38) were used for the flow cytometry analysis to monitor the generation of these cells. This tutorial contains key steps of CytoTree time-course workflow, including how to calculate the pseudotime and how to define cell subsets and rebuild an CYT object using CytoTree. This use case also provided a framework for time-course cytometric data analysis and might provide support for research on stem cell reprogramming. The data in this chapter can be download from GitHub via git clone https://github.com/JhuangLab/CytoTree-dataset.git. And through this chapter, you will learn: How to run time course cytometry data using CytoTree. A framework for time course cytometry data analysis How to illustrate biological process using CytoTree. 5.1 Step 1. Preprocessing # Loading packages suppressMessages({ library(ggplot2) library(pheatmap) library(CytoTree) library(stringr) }) ######################### # Read Flow Cytometry Data # It can be downloaded via `git clone https://github.com/ytdai/CytoTree-dataset.git` # fcs.path musted be modified based on the download directory from GitHub fcs.path &lt;- &quot;FCS/time_course/&quot; fcs.files &lt;- paste0(fcs.path, &quot;D&quot;, c(0,2,4,6,8,10), &quot;.fcs&quot;) ########################################### # Get the expression matrix from FCS file ########################################### set.seed(1) fcs.data &lt;- runExprsMerge(fcs.files, comp = F, transformMethod = &quot;none&quot;, fixedNum = 2000) # Refine colnames of fcs data # for usecase 2 recol &lt;- c(`FITC-A&lt;CD43&gt;` = &quot;CD43&quot;, `APC-A&lt;CD34&gt;` = &quot;CD34&quot;, `BV421-A&lt;CD90&gt;` = &quot;CD90&quot;, `BV510-A&lt;CD45RA&gt;` = &quot;CD45RA&quot;, `BV605-A&lt;CD31&gt;` = &quot;CD31&quot;, `BV650-A&lt;CD49f&gt;` = &quot;CD49f&quot;, `BV 735-A&lt;CD73&gt;` = &quot;CD73&quot;, `BV786-A&lt;CD45&gt;` = &quot;CD45&quot;, `PE-A&lt;FLK1&gt;` = &quot;FLK1&quot;, `PE-Cy7-A&lt;CD38&gt;` = &quot;CD38&quot;) colnames(fcs.data)[match(names(recol), colnames(fcs.data))] = recol fcs.data &lt;- fcs.data[, recol] # Build an CYT object # If you don&#39;t want to see the running log information, set verbose FALSE day.list &lt;- c(&quot;D0&quot;, &quot;D2&quot;, &quot;D4&quot;, &quot;D6&quot;, &quot;D8&quot;, &quot;D10&quot;) meta.data &lt;- data.frame(cell = rownames(fcs.data), stage = str_replace(rownames(fcs.data), regex(&quot;_.+&quot;), &quot;&quot;) ) meta.data$stage &lt;- factor(as.character(meta.data$stage), levels = day.list) markers &lt;- c(&quot;CD43&quot;, &quot;CD34&quot;, &quot;CD90&quot;, &quot;CD45RA&quot;, &quot;CD31&quot;, &quot;CD49f&quot;, &quot;CD73&quot;, &quot;CD45&quot;, &quot;FLK1&quot;, &quot;CD38&quot;) cyt &lt;- createCYT(raw.data = fcs.data, markers = markers, meta.data = meta.data, normalization.method = &quot;log&quot;) 5.2 Step 2. Trajectory # Cluster cells by SOM algorithm # Set random seed to make results reproducible set.seed(80) cyt &lt;- runCluster(cyt, cluster.method = &quot;som&quot;, xdim = 6, ydim = 6) ## Mapping data to SOM # Do not perform downsampling set.seed(2) cyt &lt;- processingCluster(cyt, downsampling.size = 1) # run Principal Component Analysis (PCA) cyt &lt;- runFastPCA(cyt) # run t-Distributed Stochastic Neighbor Embedding (tSNE) set.seed(1) cyt &lt;- runTSNE(cyt) # run Diffusion map cyt &lt;- runDiffusionMap(cyt) # run Uniform Manifold Approximation and Projection (UMAP) cyt &lt;- runUMAP(cyt) # build minimum spanning tree based on UMAP cyt &lt;- buildTree(cyt, dim.type = &quot;umap&quot;, dim.use = 1:2) ########################################### # This is visualization module ########################################### # Plot marker density plotMarkerDensity(cyt) # Plot 2D PCA. And cells are colored by stage plot2D(cyt, item.use = c(&quot;PC_1&quot;, &quot;PC_2&quot;), color.by = &quot;stage&quot;, alpha = 1, main = &quot;tSNE&quot;, category = &quot;categorical&quot;) + scale_color_manual(values = c(&quot;#00599F&quot;,&quot;#009900&quot;,&quot;#FF9933&quot;, &quot;#FF99FF&quot;,&quot;#7A06A0&quot;,&quot;#FF3222&quot;)) # Plot 2D tSNE. And cells are colored by stage plot2D(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), color.by = &quot;stage&quot;, alpha = 1, main = &quot;tSNE&quot;, category = &quot;categorical&quot;) + scale_color_manual(values = c(&quot;#00599F&quot;,&quot;#009900&quot;,&quot;#FF9933&quot;, &quot;#FF99FF&quot;,&quot;#7A06A0&quot;,&quot;#FF3222&quot;)) # Plot 2D diffusion maps. And cells are colored by stage plot2D(cyt, item.use = c(&quot;DC_1&quot;, &quot;DC_2&quot;), color.by = &quot;stage&quot;, alpha = 1, main = &quot;tSNE&quot;, category = &quot;categorical&quot;) + scale_color_manual(values = c(&quot;#00599F&quot;,&quot;#009900&quot;,&quot;#FF9933&quot;, &quot;#FF99FF&quot;,&quot;#7A06A0&quot;,&quot;#FF3222&quot;)) # Plot 2D UMAP. And cells are colored by stage plot2D(cyt, item.use = c(&quot;UMAP_1&quot;, &quot;UMAP_2&quot;), color.by = &quot;stage&quot;, alpha = 1, main = &quot;tSNE&quot;, category = &quot;categorical&quot;) + scale_color_manual(values = c(&quot;#00599F&quot;,&quot;#009900&quot;,&quot;#FF9933&quot;, &quot;#FF99FF&quot;,&quot;#7A06A0&quot;,&quot;#FF3222&quot;)) # Plot 2D tSNE. And cells are colored by cluster id plot2D(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), color.by = &quot;cluster.id&quot;, alpha = 1, main = &quot;tSNE&quot;, category = &quot;categorical&quot;, show.cluser.id = T) # Plot 2D UMAP. And cells are colored by cluster id plot2D(cyt, item.use = c(&quot;UMAP_1&quot;, &quot;UMAP_2&quot;), color.by = &quot;cluster.id&quot;, alpha = 1, main = &quot;UMAP&quot;, category = &quot;categorical&quot;, show.cluser.id = T) # Plot 2D tSNE. And cells are colored by CD43 markers expression plot2D(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), color.by = &quot;CD43&quot;, main = &quot;tSNE CD43&quot;, category = &quot;numeric&quot;) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;,&quot;#EEEEEE&quot;,&quot;#FF3222&quot;)) # Plot 2D UMAP. And cells are colored by CD43 markers expression plot2D(cyt, item.use = c(&quot;UMAP_1&quot;, &quot;UMAP_2&quot;), color.by = &quot;CD43&quot;, main = &quot;UMAP CD43&quot;, category = &quot;numeric&quot;) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;,&quot;#EEEEEE&quot;,&quot;#FF3222&quot;)) # Plot 2D UMAP. And cells are colored by stage plot2D(cyt, item.use = c(&quot;UMAP_1&quot;, &quot;UMAP_2&quot;), color.by = &quot;stage&quot;, alpha = 1, main = &quot;UMAP&quot;, category = &quot;categorical&quot;) + scale_color_manual(values = c(&quot;#00599F&quot;,&quot;#009900&quot;,&quot;#FF9933&quot;, &quot;#FF99FF&quot;,&quot;#7A06A0&quot;,&quot;#FF3222&quot;)) # Tree plot plotTree(cyt, color.by = &quot;CD49f&quot;, show.node.name = T, cex.size = 1) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;, &quot;#EEEEEE&quot;, &quot;#FF3222&quot;)) plotTree(cyt, color.by = &quot;D0.percent&quot;, show.node.name = T, cex.size = 1) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;, &quot;#EEEEEE&quot;, &quot;#FF3222&quot;)) # plot clusters plotCluster(cyt, item.use = c(&quot;PC_1&quot;, &quot;PC_2&quot;), category = &quot;numeric&quot;, size = 10, color.by = &quot;CD45RA&quot;) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;, &quot;#EEEEEE&quot;, &quot;#FF3222&quot;)) plotCluster(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), category = &quot;numeric&quot;, size = 100, color.by = &quot;CD45RA&quot;) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;, &quot;#EEEEEE&quot;, &quot;#FF3222&quot;)) # plot pie tree plotPieTree(cyt, cex.size = 3, size.by.cell.number = T) + scale_fill_manual(values = c(&quot;#00599F&quot;,&quot;#009900&quot;,&quot;#FF9933&quot;, &quot;#FF99FF&quot;,&quot;#7A06A0&quot;,&quot;#FF3222&quot;)) plotPieTree(cyt, cex.size = 5, size.by.cell.number = T, as.tree = T, root.id = 15) + scale_fill_manual(values = c(&quot;#00599F&quot;,&quot;#009900&quot;,&quot;#FF9933&quot;, &quot;#FF99FF&quot;,&quot;#7A06A0&quot;,&quot;#FF3222&quot;)) # plot pie cluster plotPieCluster(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), cex.size = 50) + scale_fill_manual(values = c(&quot;#00599F&quot;,&quot;#009900&quot;,&quot;#FF9933&quot;, &quot;#FF99FF&quot;,&quot;#7A06A0&quot;,&quot;#FF3222&quot;)) plotPieCluster(cyt, item.use = c(&quot;PC_1&quot;, &quot;PC_2&quot;), cex.size = 0.5) + scale_fill_manual(values = c(&quot;#00599F&quot;,&quot;#009900&quot;,&quot;#FF9933&quot;, &quot;#FF99FF&quot;,&quot;#7A06A0&quot;,&quot;#FF3222&quot;)) plotPieCluster(cyt, item.use = c(&quot;UMAP_1&quot;, &quot;UMAP_2&quot;), cex.size = 5) + scale_fill_manual(values = c(&quot;#00599F&quot;,&quot;#009900&quot;,&quot;#FF9933&quot;, &quot;#FF99FF&quot;,&quot;#7A06A0&quot;,&quot;#FF3222&quot;)) # plot cluster plotCluster(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), size = 10, show.cluser.id = T) plotCluster(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), color.by = &quot;CD43&quot;, size = 10, show.cluser.id = T, category = &quot;numeric&quot;) + scale_colour_gradientn(colors = c(&quot;#00599F&quot;, &quot;#EEEEEE&quot;, &quot;#FF3222&quot;)) 5.3 Step 3. Pseudotime ########################################### # Pseudotime ########################################### cyt &lt;- defRootCells(cyt, root.cells = c(15)) cyt &lt;- runPseudotime(cyt, verbose = T, dim.type = &quot;raw&quot;) ## 2020-10-31 19:41:24 Calculating Pseudotime. ## 2020-10-31 19:41:24 The log data will be used to calculate pseudotime ## 2020-10-31 19:41:44 Calculating Pseudotime completed. # tSNE plot colored by pseudotime plot2D(cyt, item.use = c(&quot;tSNE_1&quot;, &quot;tSNE_2&quot;), category = &quot;numeric&quot;, size = 1, color.by = &quot;pseudotime&quot;) + scale_colour_gradientn(colors = c(&quot;#F4D31D&quot;, &quot;#FF3222&quot;,&quot;#7A06A0&quot;)) # UMAP plot colored by pseudotime plot2D(cyt, item.use = c(&quot;UMAP_1&quot;, &quot;UMAP_2&quot;), category = &quot;numeric&quot;, size = 1, color.by = &quot;pseudotime&quot;) + scale_colour_gradientn(colors = c(&quot;#F4D31D&quot;, &quot;#FF3222&quot;,&quot;#7A06A0&quot;)) # Tree plot plotTree(cyt, color.by = &quot;pseudotime&quot;, cex.size = 1.5) + scale_colour_gradientn(colors = c(&quot;#F4D31D&quot;, &quot;#FF3222&quot;,&quot;#7A06A0&quot;)) # denisty plot by different stage plotPseudotimeDensity(cyt, adjust = 1) + scale_color_manual(values = c(&quot;#00599F&quot;,&quot;#009900&quot;,&quot;#FF9933&quot;, &quot;#FF99FF&quot;,&quot;#7A06A0&quot;,&quot;#FF3222&quot;)) # trajectory value plotPseudotimeTraj(cyt, var.cols = T) + scale_colour_gradientn(colors = c(&quot;#F4D31D&quot;, &quot;#FF3222&quot;,&quot;#7A06A0&quot;)) ## `geom_smooth()` using formula &#39;y ~ x&#39; plotPseudotimeTraj(cyt, cutoff = 0.05, var.cols = T) + scale_colour_gradientn(colors = c(&quot;#F4D31D&quot;, &quot;#FF3222&quot;,&quot;#7A06A0&quot;)) ## `geom_smooth()` using formula &#39;y ~ x&#39; plotHeatmap(cyt, downsize = 1000, cluster_rows = T, clustering_method = &quot;ward.D&quot;, color = colorRampPalette(c(&quot;#00599F&quot;,&quot;#EEEEEE&quot;,&quot;#FF3222&quot;))(100)) 5.4 Step 4. Subset CYT ########################################### # Subset CYT ########################################### cell.inter &lt;- fetchCell(cyt, cluster.id = c(26,25,36,19,4,8,31,20,29,6,16)) cell.inter &lt;- cell.inter[grep(&quot;D6|D8|D10&quot;, cell.inter)] sub.cyt &lt;- subsetCYT(cyt, cells = cell.inter) set.seed(1) sub.cyt &lt;- runCluster(sub.cyt, cluster.method = &quot;som&quot;, xdim = 4, ydim = 4) ## Mapping data to SOM # Do not perform downsampling set.seed(1) sub.cyt &lt;- processingCluster(sub.cyt, perplexity = 2, downsampling.size = 1) # run Diffusion map set.seed(1) sub.cyt &lt;- runDiffusionMap(sub.cyt) sub.cyt &lt;- defRootCells(sub.cyt, root.cells = c(13)) sub.cyt &lt;- runPseudotime(sub.cyt, dim.type = &quot;raw&quot;, dim.use = 1:2) # 3D plot for CYT plot3D(sub.cyt, item.use = c(&quot;DC_2&quot;,&quot;DC_1&quot;,&quot;DC_3&quot;), color.by = &quot;stage&quot;, size = 0.5, angle = 60, color.theme = c(&quot;#FF99FF&quot;,&quot;#7A06A0&quot;,&quot;#FF3222&quot;)) plot3D(sub.cyt, item.use = c(&quot;DC_2&quot;,&quot;DC_1&quot;,&quot;DC_3&quot;), size = 0.5, color.by = &quot;CD49f&quot;, angle = 60, category = &quot;numeric&quot;, color.theme = c(&quot;#00599F&quot;,&quot;#00599F&quot;,&quot;#EEEEEE&quot;,&quot;#FF3222&quot;,&quot;#FF3222&quot;)) plot3D(sub.cyt, item.use = c(&quot;DC_2&quot;,&quot;DC_1&quot;,&quot;DC_3&quot;), size = 0.5, color.by = &quot;CD43&quot;, angle = 60, category = &quot;numeric&quot;, color.theme = c(&quot;#00599F&quot;,&quot;#00599F&quot;,&quot;#EEEEEE&quot;,&quot;#FF3222&quot;,&quot;#FF3222&quot;)) plot3D(sub.cyt, item.use = c(&quot;DC_2&quot;,&quot;DC_1&quot;,&quot;DC_3&quot;), size = 0.5, color.by = &quot;pseudotime&quot;, angle = 60, category = &quot;numeric&quot;, color.theme = c(&quot;#F4D31D&quot;, &quot;#FF3222&quot;,&quot;#7A06A0&quot;)) "],["advanced-usage.html", "Chapter 6 Advanced Usage", " Chapter 6 Advanced Usage First, we build a CYT object with data in the extend data of CytoTree and build the tree-shaped trajectory. # Loading packages suppressMessages({ library(CytoTree) }) # Read fcs files fcs.path &lt;- system.file(&quot;extdata&quot;, package = &quot;CytoTree&quot;) fcs.files &lt;- list.files(fcs.path, pattern = &#39;.FCS$&#39;, full = TRUE) fcs.data &lt;- runExprsMerge(fcs.files, comp = FALSE, transformMethod = &quot;none&quot;) # Refine colnames of fcs data recol &lt;- c(`FITC-A&lt;CD43&gt;` = &quot;CD43&quot;, `APC-A&lt;CD34&gt;` = &quot;CD34&quot;, `BV421-A&lt;CD90&gt;` = &quot;CD90&quot;, `BV510-A&lt;CD45RA&gt;` = &quot;CD45RA&quot;, `BV605-A&lt;CD31&gt;` = &quot;CD31&quot;, `BV650-A&lt;CD49f&gt;` = &quot;CD49f&quot;, `BV 735-A&lt;CD73&gt;` = &quot;CD73&quot;, `BV786-A&lt;CD45&gt;` = &quot;CD45&quot;, `PE-A&lt;FLK1&gt;` = &quot;FLK1&quot;, `PE-Cy7-A&lt;CD38&gt;` = &quot;CD38&quot;) colnames(fcs.data)[match(names(recol), colnames(fcs.data))] = recol fcs.data &lt;- fcs.data[, recol] # Build the CYT object cyt &lt;- createCYT(raw.data = fcs.data, normalization.method = &quot;log&quot;) # Run CytoTree as pipeline and visualize as tree set.seed(1) cyt &lt;- cyt %&gt;% runCluster() %&gt;% processingCluster() %&gt;% runFastPCA() %&gt;% runTSNE() %&gt;% runDiffusionMap() %&gt;% runUMAP() %&gt;% buildTree() ## Mapping data to SOM plotPieTree(cyt) The first advanced usage is to fetch plot meta information of CytoTree. # Fetching plot meta information for each cell plot.meta &lt;- fetchPlotMeta(cyt) head(plot.meta) # Fetching plot meta information for each cluster cluster.meta &lt;- fetchClustMeta(cyt) head(cluster.meta) # Or fetching cells cell.fetch &lt;- fetchCell(cyt, stage = c(&quot;D0&quot;, &quot;D10&quot;)) head(cell.fetch) The second advanced usage of CytoTree is to add meta-information to meta.data # Add meta-information in CytoTree meta.data meta.information &lt;- gsub(&quot;.FCS.+&quot;, &quot;&quot;, rownames(fcs.data)) meta.information[!meta.information %in% &quot;D0&quot;] &lt;- &quot;not_D0&quot; names(meta.information) &lt;- rownames(fcs.data) # Change stage cyt &lt;- addMetaData(cyt, meta.info = meta.information, name = &quot;stage&quot;) plotPieTree(cyt) # Run PCA and view cell information as our new column cyt &lt;- runFastPCA(cyt) cyt &lt;- addMetaData(cyt, meta.info = meta.information, name = &quot;Mycol&quot;) plot2D(cyt, color.by = &quot;Mycol&quot;, item.use = c(&quot;PC_1&quot;, &quot;PC_2&quot;)) "],["structure-of-cytotree.html", "Chapter 7 Structure of CytoTree", " Chapter 7 Structure of CytoTree The CYT object is according to the R S4 object. The raw.data which consists of the imput matrix data information is required to build the CYT object. When running the CytoTree::createCYT function, log.data in the CYT object is the log-transformed matrix and is filtered according to the markers included in raw.data. The log.data is essential for the next workflow. The slots som and cluster contain clustering information and parameter of clustering module, whereas pca.sdev, pca.value, pca.score, tsne.value, dm, umap.value store the running parameters and results of dimensionality reduction module. The network built by MST is stored in network slots. The root cells and leaf cells are stored in the slots root.cells and leaf.cells and are essential for pseudotime estimation and trajectory inference. The slots knn, knn.index and knn.distance contain the KNN information calculated by the R BiocNeighbors package. And the slots walk and diff.tree contains the intermediate calculation results in the pseudotime and trajectory analysis. The meta-information for cells and clusters are stored in the slots plot.meta and tree.meta, which can be fetched by CytoTree::fetchPlotMeta and CytoTree::fetchClustMeta, respectively. All slots are constrained based on the standardized data type in R. Table 7.1: Structure of CYT object Function Slot Description Type Basic raw.data Raw signal data captured from FCS matrix Basic log.data Data enrolled in the computational modules matrix Basic meta.data Meta data information of the experiment, and columns of “stage” and “cell” are required data.frame Basic markers Markers used in the calculation of PCA, tSNE, diffusion map and UMAP. vector Basic markers.idx Index of markers vector Basic cell.name Cell names after downsampling vector Clustering som Store som network information calculated using FlowSOM list Clustering cluster Store clustering information after processing cell clusters data.frame Dimensionality Reduction pca.sdev Storing PCA information vector Dimensionality Reduction pca.value Storing PCA information matrix Dimensionality Reduction pca.scores Storing PCA information matrix Dimensionality Reduction tsne.value Storing tSNE information matrix Dimensionality Reduction dm Storing diffusion maps information S4 object Dimensionality Reduction umap.value Storing UMAP information matrix Pseudotime root.cells Root cells vector Pseudotime leaf.cells Leaf cells vector Pseudotime network Minimum spanning tree information list Pseudotime knn Numbers of nearest neighbors numeric Pseudotime knn.index Matrix corresponds to a point in log.data and contains the row indices in log.data matrix Pseudotime knn.distance Contains the distance of nearest neighbors of each cell matrix Intermediate state walk Walk parameters between leaf cells and root cells list Intermediate state diff.tree Storing walking information list Meta information plot.meta Meta information for single cells in visualization data.frame Meta information tree.meta Meta information for clusters in visualization list "],["about-cytotree.html", "Chapter 8 About CytoTree Bug Reports Current version Acknowledgement Session Information Reference", " Chapter 8 About CytoTree Bug Reports If there is any error in installing or librarying the CytoTree package, please contact us via e-mail forlynna@sjtu.edu.cn. Current version Version: 1.0.2 Release Date: 2020-11-01 Acknowledgement This work was supported by the National Key Research and Development Plan of China Grants [No. 2018YFA0107802], the National Natural Science Foundation of China (NSFC) General Program [No. 81570122, 81670094, 81770205, 81830007], the National Key Research and Development Program [No. 2016YFC0902800], and the Shanghai Municipal Education Commission-Gaofeng Clinical Medicine Grant Support [No. 20161303], Shanghai Collaborative Innovation Program on Regenerative Medicine and Stem Cell Research [No. 2019CXJQ01], Mayo Clinic Center for Individualized Medicine. We thank the Center for High Performance Computing of Shanghai Jiao Tong University for providing computing support. We thank Prof. Guangchuang Yu at Southern Medical University for his kind comments and advices of CytoTree. Session Information # Show session information sessionInfo() ## R version 4.0.2 (2020-06-22) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Catalina 10.15.7 ## ## Matrix products: default ## BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] stringr_1.4.0 pheatmap_1.0.12 ggthemes_4.2.0 ggplot2_3.3.2 CytoTree_1.0.2 igraph_1.2.5 LSD_4.1-0 ## [8] flowCore_2.0.1 ## ## loaded via a namespace (and not attached): ## [1] reticulate_1.16 RUnit_0.4.32 tidyselect_1.1.0 RSQLite_2.2.0 ## [5] AnnotationDbi_1.50.3 grid_4.0.2 ranger_0.12.1 BiocParallel_1.22.0 ## [9] Rtsne_0.15 scatterpie_0.1.5 munsell_0.5.0 destiny_3.2.0 ## [13] codetools_0.2-16 umap_0.2.6.0 withr_2.3.0 colorspace_1.4-1 ## [17] Biobase_2.48.0 highr_0.8 knitr_1.30 rstudioapi_0.11 ## [21] stats4_4.0.2 SingleCellExperiment_1.10.1 robustbase_0.93-6 vcd_1.4-8 ## [25] VIM_6.0.0 TTR_0.24.2 labeling_0.3 GenomeInfoDbData_1.2.3 ## [29] polyclip_1.10-0 bit64_4.0.5 farver_2.0.3 flowWorkspace_4.0.6 ## [33] vctrs_0.3.4 generics_0.0.2 xfun_0.18 R6_2.4.1 ## [37] GenomeInfoDb_1.24.2 RcppEigen_0.3.3.7.0 locfit_1.5-9.4 bitops_1.0-6 ## [41] DelayedArray_0.14.1 scales_1.1.1 nnet_7.3-14 gtable_0.3.0 ## [45] sva_3.36.0 RProtoBufLib_2.0.0 rlang_0.4.8 genefilter_1.70.0 ## [49] scatterplot3d_0.3-41 flowUtils_1.52.0 splines_4.0.2 hexbin_1.28.1 ## [53] BiocManager_1.30.10 yaml_2.2.1 abind_1.4-5 RBGL_1.64.0 ## [57] tools_4.0.2 bookdown_0.21.2 ellipsis_0.3.1 RColorBrewer_1.1-2 ## [61] proxy_0.4-24 BiocGenerics_0.34.0 Rcpp_1.0.5 plyr_1.8.6 ## [65] base64enc_0.1-3 zlibbioc_1.34.0 purrr_0.3.4 RCurl_1.98-1.2 ## [69] FlowSOM_1.20.0 openssl_1.4.3 S4Vectors_0.26.1 zoo_1.8-8 ## [73] SummarizedExperiment_1.18.2 haven_2.3.1 cluster_2.1.0 magrittr_1.5 ## [77] ncdfFlow_2.34.0 data.table_1.13.0 RSpectra_0.16-0 openxlsx_4.2.2 ## [81] gmodels_2.18.1 lmtest_0.9-38 RANN_2.6.1 pcaMethods_1.80.0 ## [85] matrixStats_0.56.0 hms_0.5.3 evaluate_0.14 xtable_1.8-4 ## [89] smoother_1.1 XML_3.99-0.5 rio_0.5.16 jpeg_0.1-8.1 ## [93] mclust_5.4.6 readxl_1.3.1 IRanges_2.22.2 gridExtra_2.3 ## [97] ggcyto_1.16.0 compiler_4.0.2 tibble_3.0.3 crayon_1.3.4 ## [101] htmltools_0.5.0 mgcv_1.8-33 corpcor_1.6.9 tidyr_1.1.2 ## [105] RcppParallel_5.0.2 DBI_1.1.0 tweenr_1.0.1 MASS_7.3-53 ## [109] boot_1.3-25 Matrix_1.2-18 car_3.0-9 gdata_2.18.0 ## [113] parallel_4.0.2 GenomicRanges_1.40.0 forcats_0.5.0 pkgconfig_2.0.3 ## [117] rvcheck_0.1.8 prettydoc_0.4.0 foreign_0.8-80 laeken_0.5.1 ## [121] sp_1.4-2 xml2_1.3.2 annotate_1.66.0 XVector_0.28.0 ## [125] digest_0.6.27 tsne_0.1-3 ConsensusClusterPlus_1.52.0 graph_1.66.0 ## [129] rmarkdown_2.5 cellranger_1.1.0 edgeR_3.30.3 curl_4.3 ## [133] gtools_3.8.2 ggplot.multistats_1.0.0 lifecycle_0.2.0 nlme_3.1-149 ## [137] jsonlite_1.7.1 carData_3.0-4 BiocNeighbors_1.6.0 askpass_1.1 ## [141] limma_3.44.3 pillar_1.4.6 lattice_0.20-41 DEoptimR_1.0-8 ## [145] survival_3.2-3 glue_1.4.2 xts_0.12.1 zip_2.1.1 ## [149] png_0.1-7 bit_4.0.4 Rgraphviz_2.32.0 ggforce_0.3.2 ## [153] class_7.3-17 stringi_1.5.3 blob_1.2.1 RcppHNSW_0.3.0 ## [157] CytoML_2.0.5 latticeExtra_0.6-29 memoise_1.1.0 dplyr_1.0.2 ## [161] cytolib_2.0.3 knn.covertree_1.0 irlba_2.3.3 e1071_1.7-3 Reference Hahne F, Arlt D, Sauermann M, Majety M, Poustka A, Wiemann S, Huber W: Statistical methods and software for the analysis of highthroughput reverse genetic assays using flow cytometry readouts. Genome Biol 2006, 7:R77. Olsen LR, Leipold MD, Pedersen CB, Maecker HT: The anatomy of single cell mass cytometry data. Cytometry A 2019, 95:156-172. Butler A, Hoffman P, Smibert P, Papalexi E, Satija R: Integrating single-cell transcriptomic data across different conditions, technologies, and species. Nat Biotechnol 2018, 36:411-420. Trapnell C, Cacchiarelli D, Grimsby J, Pokharel P, Li S, Morse M, Lennon NJ, Livak KJ, Mikkelsen TS, Rinn JL: The dynamics and regulators of cell fate decisions are revealed by pseudotemporal ordering of single cells. Nat Biotechnol 2014, 32:381-386. Kiselev VY, Yiu A, Hemberg M: scmap: projection of single-cell RNA-seq data across data sets. Nat Methods 2018, 15:359-362. Amir el AD, Davis KL, Tadmor MD, Simonds EF, Levine JH, Bendall SC, Shenfeld DK, Krishnaswamy S, Nolan GP, Pe’er D: viSNE enables visualization of high dimensional single-cell data and reveals phenotypic heterogeneity of leukemia. Nat Biotechnol 2013, 31:545-552. Haghverdi L, Buettner F, Theis FJ: Diffusion maps for high-dimensional single-cell analysis of differentiation data. Bioinformatics 2015, 31:2989-2998. Becht E, McInnes L, Healy J, Dutertre CA, Kwok IWH, Ng LG, Ginhoux F, Newell EW: Dimensionality reduction for visualizing single-cell data using UMAP. Nat Biotechnol 2018. Wang L, Hoffman RA: Standardization, Calibration, and Control in Flow Cytometry. Curr Protoc Cytom 2017, 79:1 3 1-1 3 27. Hahne F, LeMeur N, Brinkman RR, Ellis B, Haaland P, Sarkar D, Spidlen J, Strain E, Gentleman R: flowCore: a Bioconductor package for high throughput flow cytometry. BMC Bioinformatics 2009, 10:106. Sarkar D, Le Meur N, Gentleman R: Using flowViz to visualize flow cytometry data. Bioinformatics 2008, 24:878-879. Van Gassen S, Callebaut B, Van Helden MJ, Lambrecht BN, Demeester P, Dhaene T, Saeys Y: FlowSOM: Using self-organizing maps for visualization and interpretation of cytometry data. Cytometry A 2015, 87:636-645. Qiu P, Simonds EF, Bendall SC, Gibbs KD, Jr., Bruggner RV, Linderman MD, Sachs K, Nolan GP, Plevritis SK: Extracting a cellular hierarchy from high-dimensional cytometry data with SPADE. Nat Biotechnol 2011, 29:886-891. Chen H, Lau MC, Wong MT, Newell EW, Poidinger M, Chen J: Cytofkit: A Bioconductor Package for an Integrated Mass Cytometry Data Analysis Pipeline. PLoS Comput Biol 2016, 12:e1005112. Chattopadhyay PK, Winters AF, Lomas WE, 3rd, Laino AS, Woods DM: High-Parameter Single-Cell Analysis. Annu Rev Anal Chem (Palo Alto Calif) 2019, 12:411-430. Bendall SC, Davis KL, Amir el AD, Tadmor MD, Simonds EF, Chen TJ, Shenfeld DK, Nolan GP, Pe’er D: Single-cell trajectory detection uncovers progression and regulatory coordination in human B cell development. Cell 2014, 157:714-725. Nowicka M, Krieg C, Crowell HL, Weber LM, Hartmann FJ, Guglietta S, Becher B, Levesque MP, Robinson MD: CyTOF workflow: differential discovery in high-throughput high-dimensional cytometry datasets. F1000Res 2017, 6:748. Bendall SC, Simonds EF, Qiu P, Amir el AD, Krutzik PO, Finck R, Bruggner RV, Melamed R, Trejo A, Ornatsky OI, et al: Single-cell mass cytometry of differential immune and drug responses across a human hematopoietic continuum. Science 2011, 332:687-696. Herring CA, Banerjee A, McKinley ET, Simmons AJ, Ping J, Roland JT, Franklin JL, Liu Q, Gerdes MJ, Coffey RJ, Lau KS: Unsupervised Trajectory Analysis of Single-Cell RNA-Seq and Imaging Data Reveals Alternative Tuft Cell Origins in the Gut. Cell Syst 2018, 6:37-51 e39. Spidlen J, Breuer K, Rosenberg C, Kotecha N, Brinkman RR: FlowRepository: a resource of annotated flow cytometry datasets associated with peer-reviewed publications. Cytometry A 2012, 81:727-731. Doulatov S, Notta F, Laurenti E, Dick JE: Hematopoiesis: a human perspective. Cell Stem Cell 2012, 10:120-136. Laurenti E, Gottgens B: From haematopoietic stem cells to complex differentiation landscapes. Nature 2018, 553:418-426. Wang C, Tang X, Sun X, Miao Z, Lv Y, Yang Y, Zhang H, Zhang P, Liu Y, Du L, et al: TGFbeta inhibition enhances the generation of hematopoietic progenitors from human ES cell-derived hemogenic endothelial cells using a stepwise strategy. Cell Res 2012, 22:194-207. Notta F, Doulatov S, Laurenti E, Poeppl A, Jurisica I, Dick JE: Isolation of single human hematopoietic stem cells capable of long-term multilineage engraftment. Science 2011, 333:218-221. Hu Z, Jujjavarapu C, Hughey JJ, Andorf S, Lee HC, Gherardini PF, Spitzer MH, Thomas CG, Campbell J, Dunn P, et al: MetaCyto: A Tool for Automated Meta-analysis of Mass and Flow Cytometry Data. Cell Rep 2018, 24:1377-1388. Finak G, Frelinger J, Jiang W, Newell EW, Ramey J, Davis MM, Kalams SA, De Rosa SC, Gottardo R: OpenCyto: an open source infrastructure for scalable, robust, reproducible, and automated, end-to-end flow cytometry data analysis. PLoS Comput Biol 2014, 10:e1003806. Aghaeepour N, Nikolic R, Hoos HH, Brinkman RR: Rapid cell population identification in flow cytometry data. Cytometry A 2011, 79:6-13. Schubert E, Rousseeuw PJ: Faster k-Medoids Clustering: Improving the PAM, CLARA, and CLARANS Algorithms. 2018. Scrucca L, Fop M, Murphy TB, Raftery AE: mclust 5: Clustering, Classification and Density Estimation Using Gaussian Finite Mixture Models. R j 2016, 8:289-317. Leek JT, Johnson WE, Parker HS, Jaffe AE, Storey JD: The sva package for removing batch effects and other unwanted variation in high-throughput experiments. Bioinformatics 2012, 28:882-883. Saelens W, Cannoodt R, Todorov H, Saeys Y: A comparison of single-cell trajectory inference methods. Nat Biotechnol 2019. Kotecha N, Krutzik PO, Irish JM: Web-based analysis and publication of flow cytometry experiments. Curr Protoc Cytom 2010, Chapter 10:Unit10 17. Finak G, Jiang M: FlowWorkspace: Infrastructure for Representing and Interacting with the Gated Cytometry. 2011. Van P, Jiang W, Gottardo R, Finak G: ggCyto: next generation open-source visualization software for cytometry. Bioinformatics 2018, 34:3951-3953. Ito K, Murphy D: Application of ggplot2 to Pharmacometric Graphics. CPT Pharmacometrics Syst Pharmacol 2013, 2:e79. Ritchie ME, Phipson B, Wu D, Hu Y, Law CW, Shi W, Smyth GK: limma powers differential expression analyses for RNA-sequencing and microarray studies. Nucleic Acids Res 2015, 43:e47. Cao J, Spielmann M, Qiu X, Huang X, Ibrahim DM, Hill AJ, Zhang F, Mundlos S, Christiansen L, Steemers FJ, et al: The single-cell transcriptional landscape of mammalian organogenesis. Nature 2019, 566:496-502. Wang X: A Fast Exact k-Nearest Neighbors Algorithm for High Dimensional Search Using k-Means Clustering and Triangle Inequality. Proc Int Jt Conf Neural Netw 2012, 43:2351-2358. "],["about-the-author.html", "About The Author", " About The Author The author Yuting Dai is a PhD student at Shanghai Jiao Tong University. In 2016, she graduated from Shanghai Jiao Tong University and got a Bachelor Degree in Bioinformatics. Then she continued to study for a PhD in Shanghai Institute of Hematology, Shanghai Jiao Tong University. The the main research directions of her is bioinformatic tools or workflows development on multi-omics data in cancer, and the details as follow: Sequencing data analysis in cancer, e.g. whole genome sequencing, whole exom sequencing, RNA sequencing, single-cell RNA sequencing, ChIP-seq, especially leukemia. Flow and mass cytometry data analysis and software development. Visualization on multidimensional data. She has participated in several projects and here is the publication (# represents the co-first author, and * represents the corresponding author): [1] Lu Jiang#, Xue-Ping Li#, Yu-Ting Dai#, Bing Chen, Xiang-Qin Weng, Shu-Min Xiong, Min Zhang, Jin-Yan Huang*, Zhu Chen*, Sai-Juan Chen*. Multidimensional study of the heterogeneity of leukemia cells in t(8;21) acute myelogenous leukemia identifies the subtype with poor outcome. PNAS, 2020, 117(33):20117-20126. [2] Jie Xiong#, Bo-Wen Cui#, Nan Wang#, Yu-Ting Dai#, Hao Zhang#, Chao-Fu Wang#, Hui-Juan Zhong, Shu Cheng, Bin-Shen Ou-Yang, Yu Hu, Xi Zhang, Bin Xu, Wen-Bin Qian, Rong Tao, Feng Yan, Jian-Da Hu, Ming Hou, Xue-Jun Ma, Xin Wang, Yuan-Hua Liu, Zun-Min Zhu, Xiao-Bin Huang, Li Liu, Chong-Yang Wu, Li Huang, Yun-Feng Shen, Rui-Bin Huang, Jing-Yan Xu, Chun Wang, De-Pei Wu, Li Yu, Jian-Feng Li, Peng-Peng Xu, Li Wang, Jin-Yan Huang*, Sai-Juan Chen*, Wei-Li Zhao*. Genomic and Transcriptomic Characterization of Natural Killer T Cell Lymphoma. Cancer Cell, 2020, 37(3):403-419. [3] Yi Zhou#, Xingli Zhu#, Yuting Dai#, Shumin Xiong, Chuijin Wei, Pei Yu, Yuewen Tang, Liang Wu, Jianfeng Li, Dan Liu, Yanlin Wang, Zhu Chen, Sai-Juan Chen*, Jinyan Huang*, Lin Cheng*. Chemical cocktail induces hematopoietic reprogramming and expands hematopoietic stem/progenitor cells. Advanced Science, 2019. 7(1):1901785 [4] Jian-Feng Li#, Yu-Ting Dai#, Henrik Lilljebjörn#, Shu-Hong Shen, Bo-Wen Cui, Ling Bai, Yuan-Fang Liu, Mao-Xiang Qian, Yasuo Kubota, Hitoshi Kiyoi, Itaru Matsumura, Yasushi Miyazaki, Linda Olsson, Ah Moy Tan, Hany Ariffin, Jing Chen, Junko Takita, Takahiko Yasuda, Hiroyuki Mano, Bertil Johansson, Jun J. Yang, Allen Yeoh Eng Juh, Fumihiko Hayakawa, Zhu Chen*, Ching-Hon Pui*, Thoas Fioretos*, Sai-Juan Chen*, Jin-Yan Huang*. The transcriptional landscape of B-cell precursor acute lymphoblastic leukemia based on an international study of 1,223 cases. PNAS, 2018. 115(50):E11711-E11720. "]]
